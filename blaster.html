<!DOCTYPE html>
<html>
  <head>
    <title>Hello, World!</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
      <h1 class="title">Hello World! </h1>
      <p id="currentTime"></p>
      <script src="script.js"></script>
  </body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Defender</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .game-ui {
            position: relative;
            z-index: 2;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #0088ff;
        }
        
        .neon-text {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #0088ff;
        }
        
        .neon-box {
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff, 0 0 20px #0088ff;
        }
        
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }
        
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            overflow: hidden;
        }
        
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle var(--duration) infinite ease-in-out;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body class="bg-black text-white m-0 p-0 w-full h-full">
    <div id="background"></div>
    <canvas id="gameCanvas"></canvas>
    
    <div class="game-ui w-full h-full flex flex-col">
        <header class="flex justify-between p-4">
            <div class="neon-text text-xl">SCORE: <span id="score">0</span></div>
            <div class="neon-text text-xl">LEVEL: <span id="level">1</span></div>
            <div class="neon-text text-xl">LIVES: <span id="lives">3</span></div>
        </header>
        
        <main class="flex-1 flex items-center justify-center">
            <div id="startScreen" class="text-center">
                <h1 class="neon-text text-5xl mb-6">COSMIC DEFENDER</h1>
                <p class="neon-text text-xl mb-8">Defend the galaxy from alien invaders!</p>
                <button id="startBtn" class="neon-box bg-black/50 text-white px-8 py-3 text-2xl rounded hover:bg-blue-900/50 transition-all">
                    START MISSION
                </button>
                <div class="mt-8 neon-text">
                    <p>CONTROLS: Mouse/Touch to Move | Click/Tap to Shoot</p>
                </div>
            </div>
            
            <div id="gameOverScreen" class="text-center hidden">
                <h1 class="neon-text text-5xl mb-6 text-red-400">MISSION FAILED</h1>
                <p class="neon-text text-2xl mb-4">Final Score: <span id="finalScore">0</span></p>
                <p class="neon-text text-xl mb-8">You reached Level <span id="finalLevel">1</span></p>
                <button id="restartBtn" class="neon-box bg-black/50 text-white px-8 py-3 text-2xl rounded hover:bg-blue-900/50 transition-all">
                    TRY AGAIN
                </button>
            </div>
        </main>
        
        <footer class="p-4 text-center neon-text text-sm">
            <p>Hold position for shield recharge | Collect power-ups</p>
        </footer>
    </div>

    <script>
        // Game Configuration
        const config = {
            player: {
                size: 40,
                speed: 8,
                fireRate: 300,
                shieldRechargeRate: 0.5
            },
            enemy: {
                baseSpeed: 2,
                speedIncrease: 0.2,
                spawnRate: 2000,
                spawnReduction: 50
            },
            bullet: {
                speed: 10,
                size: 6
            },
            particle: {
                count: 20,
                size: 3,
                speed: 2,
                lifetime: 1000
            },
            powerups: {
                types: ['shield', 'rapidfire', 'multishot'],
                spawnChance: 0.02,
                duration: 10000
            },
            level: {
                enemiesToNextLevel: 10,
                levelMultiplier: 1.2
            }
        };

        // Game State
        let score = 0;
        let level = 1;
        let lives = 3;
        let gameActive = false;
        let animationId;
        let lastFireTime = 0;
        let enemiesDefeated = 0;
        let powerups = [];
        let powerupActive = null;
        let powerupEndTime = 0;
        
        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game Objects
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            width: config.player.size,
            height: config.player.size,
            speed: config.player.speed,
            shield: 100,
            lastShieldRecharge: 0,
            isMoving: false
        };
        
        let bullets = [];
        let enemies = [];
        let particles = [];
        
        // Create Stars Background
        function createStars() {
            const background = document.getElementById('background');
            background.innerHTML = '';
            
            const starCount = Math.floor(window.innerWidth * window.innerHeight / 1000);
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                const size = Math.random() * 3;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.opacity = Math.random();
                star.style.setProperty('--duration', `${Math.random() * 5 + 3}s`);
                
                background.appendChild(star);
            }
        }
        
        createStars();
        
        // Create Particles
        function createParticles(x, y, color, count = config.particle.count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * config.particle.speed;
                
                particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * config.particle.size + 1,
                    color,
                    lifetime: config.particle.lifetime,
                    born: Date.now()
                });
            }
        }
        
        // Power-up System
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.type = type;
                this.speed = 2;
                this.collected = false;
            }
            
            draw() {
                ctx.save();
                ctx.beginPath();
                
                switch(this.type) {
                    case 'shield':
                        ctx.fillStyle = '#00ffff';
                        ctx.arc(this.x, this.y, this.width/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                        
                    case 'rapidfire':
                        ctx.fillStyle = '#ff00ff';
                        ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                        break;
                        
                    case 'multishot':
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - this.height/2);
                        ctx.lineTo(this.x + this.width/2, this.y + this.height/2);
                        ctx.lineTo(this.x - this.width/2, this.y + this.height/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                }
                
                ctx.restore();
            }
            
            update() {
                this.y += this.speed;
                
                // Check collision with player
                if (!this.collected &&
                    this.x + this.width/2 > player.x - player.width/2 &&
                    this.x - this.width/2 < player.x + player.width/2 &&
                    this.y + this.height/2 > player.y - player.height/2 &&
                    this.y - this.height/2 < player.y + player.height/2) {
                    
                    this.collected = true;
                    activatePowerUp(this.type);
                    createParticles(this.x, this.y, 'white', 30);
                }
                
                return this.y < canvas.height + this.height && !this.collected;
            }
        }
        
        function activatePowerUp(type) {
            powerupActive = type;
            powerupEndTime = Date.now() + config.powerups.duration;
            
            switch(type) {
                case 'shield':
                    player.shield = Math.min(player.shield + 50, 100);
                    break;
                    
                case 'rapidfire':
                    // Fire rate is handled in the fireBullet function
                    break;
                    
                case 'multishot':
                    // Firing is handled in the fireBullet function
                    break;
            }
        }
        
        function checkPowerupExpired() {
            if (powerupActive && Date.now() > powerupEndTime) {
                powerupActive = null;
            }
        }
        
        // Enemy System
        class Enemy {
            constructor() {
                this.width = 40;
                this.height = 40;
                this.x = Math.random() * (canvas.width - this.width);
                this.y = -this.height;
                this.speed = config.enemy.baseSpeed + (level * config.enemy.speedIncrease);
                this.health = 1;
                this.color = `hsl(${Math.random() * 60 + 300}, 80%, 60%)`;
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width/2, this.y + this.height);
                ctx.closePath();
                ctx.fill();
                
                // Draw health bar if needed
                if (this.health < 1) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y - 10, this.width * this.health, 5);
                }
                
                ctx.restore();
            }
            
            update() {
                this.y += this.speed;
                
                // Check collision with player
                if (this.y + this.height > player.y - player.height/2 &&
                    this.y < player.y + player.height/2 &&
                    this.x + this.width > player.x - player.width/2 &&
                    this.x < player.x + player.width/2) {
                    
                    if (powerupActive !== 'shield') {
                        lives--;
                        document.getElementById('lives').textContent = lives;
                        
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                    
                    createParticles(this.x + this.width/2, this.y + this.height/2, this.color, 30);
                    return false;
                }
                
                return this.y < canvas.height + this.height;
            }
        }
        
        function spawnEnemy() {
            if (!gameActive) return;
            
            enemies.push(new Enemy());
            
            // Schedule next enemy spawn
            const spawnDelay = Math.max(500, config.enemy.spawnRate - (level * config.enemy.spawnReduction));
            setTimeout(spawnEnemy, spawnDelay);
        }
        
        // Bullet System
        class Bullet {
            constructor(x, y, angle = -Math.PI/2, speed = config.bullet.speed) {
                this.x = x;
                this.y = y;
                this.width = config.bullet.size;
                this.height = config.bullet.size * 2;
                this.speed = speed;
                this.angle = angle;
                this.color = '#00ffff';
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.width, this.height, this.angle + Math.PI/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Check collision with enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    
                    if (this.x + this.width > enemy.x &&
                        this.x - this.width < enemy.x + enemy.width &&
                        this.y + this.height > enemy.y &&
                        this.y - this.height < enemy.y + enemy.height) {
                        
                        enemy.health -= 0.5;
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            score += 10 * level;
                            document.getElementById('score').textContent = score;
                            
                            enemiesDefeated++;
                            if (enemiesDefeated >= config.level.enemiesToNextLevel) {
                                levelUp();
                            }
                            
                            // Random chance to spawn powerup
                            if (Math.random() < config.powerups.spawnChance) {
                                const type = config.powerups.types[Math.floor(Math.random() * config.powerups.types.length)];
                                powerups.push(new PowerUp(enemy.x + enemy.width/2, enemy.y + enemy.height/2, type));
                            }
                            
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 30);
                            enemies.splice(i, 1);
                        }
                        
                        createParticles(this.x, this.y, this.color, 10);
                        return false;
                    }
                }
                
                return this.y > -this.height && 
                       this.y < canvas.height + this.height &&
                       this.x > -this.width && 
                       this.x < canvas.width + this.width;
            }
        }
        
        function fireBullet() {
            if (!gameActive) return;
            
            const now = Date.now();
            const fireDelay = powerupActive === 'rapidfire' ? config.player.fireRate / 3 : config.player.fireRate;
            
            if (now - lastFireTime > fireDelay) {
                lastFireTime = now;
                
                if (powerupActive === 'multishot') {
                    // Fire three bullets at slightly different angles
                    bullets.push(new Bullet(player.x, player.y - player.height/2));
                    bullets.push(new Bullet(player.x, player.y - player.height/2, -Math.PI/2 - 0.2));
                    bullets.push(new Bullet(player.x, player.y - player.height/2, -Math.PI/2 + 0.2));
                } else {
                    bullets.push(new Bullet(player.x, player.y - player.height/2));
                }
                
                createParticles(player.x, player.y - player.height/2, '#00ffff', 5);
            }
        }
        
        // Game Progress
        function levelUp() {
            level++;
            enemiesDefeated = 0;
            document.getElementById('level').textContent = level;
            
            // Visual effect for level up
            for (let i = 0; i < 100; i++) {
                createParticles(
                    Math.random() * canvas.width, 
                    Math.random() * canvas.height, 
                    `hsl(${Math.random() * 60 + 200}, 100%, 50%)`,
                    1
                );
            }
        }
        
        // Game Loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                p.x += p.vx;
                p.y += p.vy;
                p.lifetime -= 16;
                
                const alpha = Math.min(1, p.lifetime / 500);
                
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                if (p.lifetime <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update and draw bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update();
                bullets[i].draw();
                
                if (!bullets[i].update()) {
                    bullets.splice(i, 1);
                }
            }
            
            // Update and draw enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].update();
                enemies[i].draw();
                
                if (!enemies[i].update()) {
                    enemies.splice(i, 1);
                }
            }
            
            // Update and draw powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                if (powerups[i].update()) {
                    powerups[i].draw();
                } else {
                    powerups.splice(i, 1);
                }
            }
            
            // Draw player
            ctx.save();
            
            // Draw shield if active
            if (powerupActive === 'shield') {
                const shieldSize = player.width * 1.5;
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x, player.y, shieldSize/2, 0, Math.PI * 2);
                ctx.stroke();
                
                // Pulsing effect
                const pulse = Math.sin(Date.now() / 200) * 5;
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + Math.abs(pulse)/10})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(player.x, player.y, shieldSize/2 + pulse, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw player ship
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - player.height/2);
            ctx.lineTo(player.x + player.width/2, player.y + player.height/2);
            ctx.lineTo(player.x - player.width/2, player.y + player.height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw engine glow when moving
            if (player.isMoving) {
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.moveTo(player.x - player.width/3, player.y + player.height/2);
                ctx.lineTo(player.x + player.width/3, player.y + player.height/2);
                ctx.lineTo(player.x, player.y + player.height/2 + 15);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();
            
            // Recharge shield when not moving
            if (!player.isMoving && Date.now() - player.lastShieldRecharge > 100) {
                player.shield = Math.min(player.shield + config.player.shieldRechargeRate, 100);
                player.lastShieldRecharge = Date.now();
            }
            
            // Draw shield meter
            if (powerupActive !== 'shield') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10, canvas.height - 30, 104, 14);
                ctx.fillStyle = `hsl(${player.shield * 1.2}, 100%, 50%)`;
                ctx.fillRect(12, canvas.height - 28, player.shield, 10);
            }
            
            // Check powerup expiration
            checkPowerupExpired();
            
            // Continue game loop
            if (gameActive) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }
        
        // Game Controls
        function handleMouseMove(e) {
            if (!gameActive) return;
            
            player.isMoving = true;
            player.x = e.clientX || e.touches[0].clientX;
            player.y = e.clientY || e.touches[0].clientY;
            
            // Keep player within bounds
            player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
            player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, player.y));
        }
        
        function handleMouseUp() {
            player.isMoving = false;
        }
        
        // Game State Management
        function startGame() {
            score = 0;
            level = 1;
            lives = 3;
            enemiesDefeated = 0;
            gameActive = true;
            
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lives').textContent = lives;
            
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            // Clear all game objects
            bullets = [];
            enemies = [];
            particles = [];
            powerups = [];
            powerupActive = null;
            
            // Reset player position
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.shield = 100;
            
            // Start game systems
            spawnEnemy();
            gameLoop();
        }
        
        function gameOver() {
            gameActive = false;
            cancelAnimationFrame(animationId);
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            
            // Create explosion effect
            for (let i = 0; i < 100; i++) {
                createParticles(
                    player.x, 
                    player.y, 
                    `hsl(${Math.random() * 60}, 100%, 50%)`,
                    1
                );
            }
        }
        
        // Event Listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('touchend', handleMouseUp);
        
        canvas.addEventListener('mousedown', fireBullet);
        canvas.addEventListener('touchstart', fireBullet);
        
        // Prevent touch scrolling
        document.addEventListener('touchmove', (e) => {
            if (gameActive) e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>